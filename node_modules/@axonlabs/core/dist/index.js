"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Axon: () => Axon,
  AxonCore: () => AxonCore,
  AxonRouter: () => AxonRouter_default,
  Router: () => Router
});
module.exports = __toCommonJS(src_exports);

// src/core/AxonCore.ts
var http = __toESM(require("http"));
var https = __toESM(require("https"));
var import_kolor = require("@spacingbat3/kolor");
var import_path_to_regexp = require("path-to-regexp");

// src/core/utils/coreLogger.ts
var import_pino = __toESM(require("pino"));
var import_pino_pretty = __toESM(require("pino-pretty"));
var prettyStream = (0, import_pino_pretty.default)({
  colorize: true,
  translateTime: "HH:MM:ss.l",
  ignore: "pid,hostname",
  customLevels: {
    fatal: 60,
    error: 50,
    warn: 40,
    request: 35,
    // HTTP request logs
    core: 34,
    // Core system messages
    coreDebug: 33,
    // Core debug messages
    info: 30,
    debug: 20,
    trace: 10
  },
  customColors: "fatal:red,error:red,core:magenta,coreDebug:blue,request:cyan,info:green,debug:yellow,trace:white"
});
var logger = (0, import_pino.default)(
  {
    level: "info",
    customLevels: {
      fatal: 60,
      error: 50,
      warn: 40,
      request: 35,
      core: 34,
      coreDebug: 33,
      info: 30,
      debug: 20,
      trace: 10
    },
    useOnlyCustomLevels: false
  },
  prettyStream
);

// src/core/utils/routePrefixHandler.ts
var addRoutePrefix = (route, prefix) => {
  route = route.toString();
  prefix = prefix.toString();
  if (route[0] === "/")
    route = route.slice(1, route.length);
  if (prefix[prefix.length - 1] === "/")
    prefix = prefix.slice(0, prefix.length - 1);
  if (prefix[0] !== "/")
    prefix = `/${prefix}`;
  route = `${prefix}/${route}`;
  return route;
};
var routePrefixHandler_default = addRoutePrefix;

// src/core/utils/getRequestBody.ts
var getRequestBody = async (req) => {
  return new Promise((resolve, reject) => {
    let body = "";
    req.on("data", (chunk) => {
      body += chunk.toString();
    });
    req.on("end", () => {
      try {
        req.body = JSON.parse(body);
        resolve(req.body);
      } catch (error) {
        req.body = body;
        resolve(req.body);
      }
    });
    req.on("error", (error) => {
      reject(error);
    });
  });
};
var getRequestBody_default = getRequestBody;

// src/Router/exceptions/RouterException.ts
var RouterException = class extends Error {
  name;
  meta;
  constructor(error) {
    super(error.msg);
    this.name = error.name;
    this.meta = error.meta;
  }
};
var RouterException_default = RouterException;

// src/core/exceptions/CoreExceptions.ts
var routeDuplicateException = (method, route) => {
  throw new RouterException_default({
    msg: "Duplicated route!",
    name: "RouterError -> DUPLICATED_ROUTE",
    meta: {
      type: "DUPLICATED_ROUTE",
      description: `route "${method} ${route}" is duplicated`
    }
  });
};

// src/core/plugin/PluginLoader.ts
var PluginLoader = class {
  plugins = [];
  async loadPlugin(plugin) {
    plugin.name = plugin.name.replace(" ", "-");
    plugin.version = plugin.version.replace(" ", "-");
    this.plugins.push(plugin);
    logger.debug(`Plugin ${plugin.name} (${plugin.version}) loaded`);
  }
  async initializePlugins(core) {
    this.plugins.forEach(async (plugin) => {
      await plugin.init(core);
      logger.info(`Plugin ${plugin.name} (${plugin.version}) initialized`);
    });
  }
  async getPlugins() {
    return this.plugins;
  }
};

// src/core/response/AxonResponse.ts
var AxonResponse = class {
  res;
  constructor(res) {
    this.res = res;
  }
  /**
   * to add custom response message
   */
  message(message) {
    this.res.statusMessage = message;
    return new Proxy(this, {
      get(target, prop) {
        if (prop === "message") {
          throw new Error("Cannot access 'message' method after it has been called.");
        }
        return target[prop];
      }
    });
  }
  /**
   * to add body for send to client as a response body.
   * 
   * **calling this method will send response to user, so ensure you called all methods which you want before this**
   * @param body the body of response to client
   */
  body(body) {
    switch (typeof body) {
      case "string":
        this.res.setHeader("Content-Type", "text/plain");
        break;
      case "object":
        this.res.setHeader("Content-Type", "application/json");
        body = JSON.stringify(body);
        break;
      default:
        this.res.setHeader("Content-Type", "application/json");
        body = JSON.stringify({});
        break;
    }
    this.res.end(body);
  }
  setHeader(key, value) {
    this.res.setHeader(key, value);
    return this;
  }
};
var AxonResponse_default = AxonResponse;

// src/core/cors/AxonCors.ts
var import_object_assign = __toESM(require("object-assign"));
var import_vary = __toESM(require("vary"));
var defaults = {
  origin: "*",
  methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
  preflightContinue: false,
  optionsSuccessStatus: 204
};
var isString = (s) => {
  return typeof s === "string" || s instanceof String;
};
var isOriginAllowed = async (origin, allowedOrigin) => {
  if (Array.isArray(allowedOrigin)) {
    for (let i = 0; i < allowedOrigin.length; ++i) {
      if (await isOriginAllowed(origin, allowedOrigin[i])) {
        return true;
      }
    }
    return false;
  } else if (isString(allowedOrigin)) {
    return origin === allowedOrigin;
  } else if (allowedOrigin instanceof RegExp) {
    return allowedOrigin.test(origin);
  } else {
    return !!allowedOrigin;
  }
};
var configureOrigin = async (options, req) => {
  let requestOrigin = req.headers.origin, headers = [], isAllowed;
  if (!options.origin || options.origin === "*") {
    headers.push([{
      key: "Access-Control-Allow-Origin",
      value: "*"
    }]);
  } else if (isString(options.origin)) {
    headers.push([{
      key: "Access-Control-Allow-Origin",
      value: options.origin
    }]);
    headers.push([{
      key: "Vary",
      value: "Origin"
    }]);
  } else {
    isAllowed = await isOriginAllowed(requestOrigin, options.origin);
    headers.push([{
      key: "Access-Control-Allow-Origin",
      value: isAllowed ? requestOrigin : false
    }]);
    headers.push([{
      key: "Vary",
      value: "Origin"
    }]);
  }
  return headers;
};
var configureMethods = async (options) => {
  let methods = options.methods;
  if (methods.join) {
    methods = options.methods.join(",");
  }
  return {
    key: "Access-Control-Allow-Methods",
    value: methods
  };
};
var configureCredentials = async (options) => {
  if (options.credentials === true) {
    return {
      key: "Access-Control-Allow-Credentials",
      value: "true"
    };
  }
  return null;
};
var configureAllowedHeaders = async (options, req) => {
  let allowedHeaders = options.allowedHeaders || options.headers;
  const headers = [];
  if (!allowedHeaders) {
    allowedHeaders = req.headers["access-control-request-headers"];
    headers.push([{
      key: "Vary",
      value: "Access-Control-Request-Headers"
    }]);
  } else if (allowedHeaders.join) {
    allowedHeaders = allowedHeaders.join(",");
  }
  if (allowedHeaders && allowedHeaders.length) {
    headers.push([{
      key: "Access-Control-Allow-Headers",
      value: allowedHeaders
    }]);
  }
  return headers;
};
var configureExposedHeaders = async (options) => {
  let headers = options.exposedHeaders;
  if (!headers) {
    return null;
  } else if (headers.join) {
    headers = headers.join(",");
  }
  if (headers && headers.length) {
    return {
      key: "Access-Control-Expose-Headers",
      value: headers
    };
  }
  return null;
};
var configureMaxAge = async (options) => {
  const maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
  if (maxAge && maxAge.length) {
    return {
      key: "Access-Control-Max-Age",
      value: maxAge
    };
  }
  return null;
};
var applyHeaders = async (headers, res) => {
  for (let i = 0, n = headers.length; i < n; i++) {
    const header = headers[i];
    if (header) {
      if (Array.isArray(header)) {
        applyHeaders(header, res);
      } else if (header.key === "Vary" && header.value) {
        (0, import_vary.default)(res, header.value);
      } else if (header.value) {
        res.setHeader(header.key, header.value);
      }
    }
  }
};
var cors = async (options, req, res, next) => {
  const headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
  if (method === "OPTIONS") {
    headers.push(await configureOrigin(options, req));
    headers.push(await configureCredentials(options));
    headers.push(await configureMethods(options));
    headers.push(await configureAllowedHeaders(options, req));
    headers.push(await configureMaxAge(options));
    headers.push(await configureExposedHeaders(options));
    await applyHeaders(headers, res);
    if (options.preflightContinue) {
      await next();
    } else {
      res.statusCode = options.optionsSuccessStatus;
      res.setHeader("Content-Length", "0");
      res.end();
    }
  } else {
    headers.push(await configureOrigin(options, req));
    headers.push(await configureCredentials(options));
    headers.push(await configureExposedHeaders(options));
    await applyHeaders(headers, res);
    await next();
  }
};
var middlewareWrapper = async (o) => {
  let optionsCallback;
  if (typeof o === "function") {
    optionsCallback = o;
  } else {
    optionsCallback = async (req, cb) => {
      await cb(null, o);
    };
  }
  return async (req, res, next) => {
    await optionsCallback(req, async (err, options) => {
      if (err) {
        return res.status(500).body({
          err,
          meta: {
            module: "AxonCors",
            root: "optionsCallback",
            line: 203
          }
        });
      } else {
        const corsOptions = (0, import_object_assign.default)({}, defaults, options);
        let originCallback = null;
        if (corsOptions.origin && typeof corsOptions.origin === "function") {
          originCallback = corsOptions.origin;
        } else if (corsOptions.origin) {
          originCallback = async (origin, cb) => {
            await cb(null, corsOptions.origin);
          };
        }
        if (originCallback) {
          await originCallback(req.headers.origin, async (err2, origin) => {
            if (err2 || !origin) {
              return res.status(500).body({
                err,
                meta: {
                  module: "AxonCors",
                  root: "optionsCallback",
                  line: 225
                }
              });
            } else {
              corsOptions.origin = origin;
              await cors(corsOptions, req, res, next);
            }
          });
        } else {
          await next();
        }
      }
    });
  };
};
var AxonCors_default = {
  middlewareWrapper
};

// src/core/config/AxonConfig.ts
var import_lilconfig = require("lilconfig");
var import_esbuild = require("esbuild");
var import_fs = require("fs");
var import_url = require("url");

// src/core/config/defaultConfig.ts
var defaultConfig_default = {
  DEBUG: false,
  LOGGER: true,
  LOGGER_VERBOSE: false,
  RESPONSE_MESSAGES: {
    notFound: "Not found",
    serverError: "Internal server error",
    methodNotAllowed: "Method {method} not allowed"
  },
  CORS: {
    origin: "*",
    methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
    preflightContinue: false
  },
  HTTPS: {}
};

// src/core/config/AxonConfig.ts
var dynamicImport = new Function("file", "return import(file)");
async function loadJSConfig(filePath) {
  const fileUrl = (0, import_url.pathToFileURL)(filePath).href;
  const module2 = await dynamicImport(fileUrl);
  return module2.default || module2;
}
function loadTSConfig(filePath) {
  const content = (0, import_fs.readFileSync)(filePath, "utf8");
  const { code } = (0, import_esbuild.transformSync)(content, {
    loader: "ts",
    target: "es2020",
    format: "cjs"
  });
  const module2 = { exports: {} };
  const fn = new Function("module", "exports", "require", code);
  fn(module2, module2.exports, require);
  return module2.exports;
}
async function resolveConfig() {
  const explorer = (0, import_lilconfig.lilconfig)("axon", {
    searchPlaces: [
      "axon.config.ts",
      "axon.config.js",
      "axon.config.cjs",
      "axon.config.mjs"
    ],
    loaders: {
      ".ts": (filePath) => loadTSConfig(filePath),
      ".mjs": (filePath) => loadJSConfig(filePath),
      ".js": (filePath) => require(filePath),
      ".cjs": (filePath) => require(filePath)
    }
  });
  const result = await explorer.search(process.cwd());
  if (!result?.config) return defaultConfig_default;
  if (Object.keys(result.config).includes("default")) result.config = result.config?.default;
  const config = { ...defaultConfig_default, ...result.config };
  if (config.DEBUG) {
    logger.level = "debug";
  }
  if (!config.LOGGER) {
    logger.level = "silent";
  }
  logger.debug(config, "Loaded config");
  return config;
}

// src/core/services/unloadRoutesService.ts
var unloadRouteService = async ({ route, method, router, _routes }) => {
  if (router) {
    const routerRoutes = router.exportRoutes();
    Object.keys(routerRoutes).forEach((method2) => {
      if (Object.keys(routerRoutes[method2]).length > 0) {
        Object.keys(routerRoutes[method2]).forEach((route2) => {
          if (_routes[method2][route2]) {
            delete _routes[method2][route2];
            delete _routes["OPTIONS"][route2];
            logger.debug(`unloaded route ${method2} ${route2}`);
          }
        });
      }
    });
  }
  if (method) {
    _routes[method] = {};
    logger.debug(`unloaded method ${method} routes`);
  }
  if (route) {
    let deleted = false;
    Object.keys(_routes).forEach((method2) => {
      if (Object.keys(_routes[method2]).length > 0) {
        Object.keys(_routes[method2]).forEach((_route) => {
          if (_route === route) {
            delete _routes[method2][_route];
            delete _routes["OPTIONS"][_route];
            deleted = true;
            logger.debug(`unloaded route ${method2} ${_route}`);
          }
        });
      }
    });
    if (!deleted) logger.debug(`route ${route} not found`);
  }
};
var unloadRoutesService = async (_routes) => {
  Object.keys(_routes).forEach((method) => {
    _routes[method] = {};
  });
  logger.debug("all routes unloaded");
  return _routes;
};

// src/core/AxonCore.ts
var defaultResponses = {
  notFound: "Not found",
  serverError: "Internal server error",
  methodNotAllowed: "Method {method} not allowed"
};
var AxonCore = class {
  routes;
  globalMiddlewares;
  config;
  configsLoaded;
  passRoutes;
  routesLoaded;
  pluginLoader = new PluginLoader();
  constructor() {
    this.routes = {
      GET: {},
      POST: {},
      PUT: {},
      PATCH: {},
      DELETE: {},
      OPTIONS: {}
    };
    this.globalMiddlewares = [];
    this.config = {};
    this.configsLoaded = false;
    this.passRoutes = true;
    this.routesLoaded = false;
  }
  /**
   * Loads a specified Axon plugin using the plugin loader.
   *
   * @param {AxonPlugin} plugin - The plugin to be loaded. It should be an instance of AxonPlugin.
   * @example
   * // this class must implements AxonPlugin type
   * class MyPlugin implements AxonPlugin {
   *      name = "plugin"
   *      version = "1.0.0"
   *
   *      init(core) {}
   * }
   *
   * core.loadPlugin(new MyPlugin())
   */
  async loadPlugin(plugin) {
    await this.pluginLoader.loadPlugin(plugin);
  }
  async #initializePlugins() {
    await this.pluginLoader.initializePlugins(this);
  }
  /**
   * A method to load core configs
   *
   */
  async #loadConfig() {
    this.config = await resolveConfig();
    this.configsLoaded = true;
  }
  /**
   * loads created routes
   * @param router instance of Router which routes set with it.
   * @param prefix
   * @example
   * const router = Router()
   *
   * router.get('/', async (req, res) => {});
   *
   * core.loadRoute(router) // without prefix
   * core.loadRoute(router, '/api/v1') // with prefix
   */
  async loadRoute(router, prefix) {
    this.passRoutes = false;
    const routerRoutes = router.exportRoutes();
    Object.keys(routerRoutes).forEach((method) => {
      if (Object.keys(routerRoutes[method]).length > 0) {
        Object.keys(routerRoutes[method]).forEach((route) => {
          if (!this.routes[method][route]) {
            const originalRoute = route;
            if (prefix) {
              route = routePrefixHandler_default(route, prefix);
            }
            if (route[0] !== "/")
              route = `/${route}`;
            if (route[route.length - 1] === "/")
              route = route.slice(0, -1);
            this.routes[method][route] = routerRoutes[method][originalRoute];
            this.routes["OPTIONS"][route] = routerRoutes[method][originalRoute];
            logger.debug(`loaded route ${method} ${route}`);
          } else {
            routeDuplicateException(method, route);
          }
        });
      }
    });
    this.routesLoaded = true;
  }
  /**
   * unload routes based on entered parameters
   * @param route
   * @param method
   * @param router
   * @example
   * // this one unloads a route with path `/api/v1/user`.
   * core.unloadRoute({
   *     route: '/api/v1/user'
   * });
   *
   * // this one unloads all  routes with method `GET`
   * core.unloadRoute({
   *     method: 'GET'
   * });
   *
   * const userRouter = Router();
   *
   * // this one unloads all routes of userRouter.
   * core.unloadRoute({
   *     router: userRouter
   * });
   *
   * // this one unloads a route with path `/api/v1/user`, all routes with method `GET` and all routes of userRouter.
   * core.unloadRoute({
   *     route: '/api/v1/user',
   *     method: "GET",
   *     router: userRouter
   * })
   */
  async unloadRoute({ route, method, router }) {
    await unloadRouteService({ _routes: this.routes, route, router, method });
  }
  /**
   * unload all routes
   * @example
   * core.unloadRoutes();
   */
  async unloadRoutes() {
    await unloadRoutesService(this.routes);
  }
  /**
   * You can set one or many middlewares in global scope with this method.
   * @example
   * core.globalMiddleware(authMiddleware)
   * core.globalMiddleware([uploadMiddleware, userMiddleware])
   * @param fn
   */
  async globalMiddleware(fn) {
    if (typeof fn === "function") {
      this.globalMiddlewares.push(fn);
    }
    if (typeof fn === "object") {
      for (const middleware of fn) {
        if (typeof middleware === "function") {
          this.globalMiddlewares.push(middleware);
        }
      }
    }
    logger.debug("global middlewares loaded");
  }
  /**
   * Http request main handler
   * @param req incoming request
   * @param res server response
   * @returns
   */
  async #handleRequest(req, res) {
    res.status = (code) => {
      res.statusCode = code;
      return new AxonResponse_default(res);
    };
    if (!Object.keys(this.routes).includes(req.method)) {
      return this.response(req, res, {
        body: {
          message: this.config.RESPONSE_MESSAGES?.methodNotAllowed?.replace("{method}", req.method) || defaultResponses.methodNotAllowed?.replace("{method}", req.method)
        },
        responseCode: 405
      });
    }
    const method = req.method;
    let foundRoute = false;
    if (Object.keys(this.routes[method]).length === 0) {
      return this.response(req, res, {
        body: {
          message: this.config.RESPONSE_MESSAGES?.notFound?.replace("{path}", req.url) || defaultResponses.notFound?.replace("{path}", req.url)
        },
        responseCode: 404
      });
    }
    for (const path of Object.keys(this.routes[method])) {
      const index = Object.keys(this.routes[method]).indexOf(path);
      let keys;
      const regexp = (0, import_path_to_regexp.pathToRegexp)(path);
      keys = regexp.keys;
      const urlRegex = /^\/{2,}$/;
      if (urlRegex.test(req.url)) {
        this.response(req, res, {
          body: {
            message: this.config.RESPONSE_MESSAGES?.notFound?.replace("{path}", req.url) || defaultResponses.notFound?.replace("{path}", req.url)
          },
          responseCode: 404
        });
        break;
      }
      const url = new URL(req.url, `http://${req.headers.host}`);
      const pathname = url.pathname;
      const match = regexp.regexp.exec(pathname);
      if (match) {
        try {
          if (!foundRoute) {
            foundRoute = true;
            const params = {};
            keys.forEach((key, index2) => {
              params[key.name] = match[index2 + 1];
            });
            req.params = params;
            const route = this.routes[method][path];
            const middlewares = route.getMiddlewares();
            const controller = route.getController();
            const axonCors = await AxonCors_default.middlewareWrapper(this.config.CORS);
            await this.handleMiddleware(req, res, async () => {
              await this.handleMiddleware(req, res, async () => {
                await this.handleMiddleware(req, res, async () => {
                  await controller(req, res);
                }, middlewares);
              }, this.globalMiddlewares);
            }, [axonCors]);
            if (this.config.LOGGER_VERBOSE) {
              logger.request({
                ip: req.socket.remoteAddress,
                url: req.url,
                method: req.method,
                headers: req.headers,
                body: req.body,
                code: res.statusCode
              }, "new http request");
            } else {
              logger.request(`${req.socket.remoteAddress} - ${req.method} ${req.url} ${res.statusCode} - ${req.headers["user-agent"]}`);
            }
          } else {
            continue;
          }
        } catch (error) {
          logger.error(error);
          this.response(req, res, {
            body: {
              message: this.config.RESPONSE_MESSAGES?.serverError || defaultResponses.serverError
            },
            responseCode: 500
          });
        }
      }
      if (!foundRoute && Object.keys(this.routes[method]).length == index + 1) {
        this.response(req, res, {
          body: {
            message: this.config.RESPONSE_MESSAGES?.notFound?.replace("{path}", req.url) || defaultResponses.notFound?.replace("{path}", req.url)
          },
          responseCode: 404
        });
      }
    }
  }
  /**
   *
   * @param req
   * @param res
   * @param next
   * @param middlewares
   */
  async handleMiddleware(req, res, next, middlewares) {
    let index = 0;
    const executeMiddleware = async () => {
      if (index < middlewares.length) {
        const middleware = middlewares[index++];
        await middleware(req, res, executeMiddleware);
      } else {
        await next();
      }
    };
    await executeMiddleware();
  }
  response(req, res, data) {
    if (data.responseMessage) {
      res.statusMessage = data.responseMessage;
    }
    if (typeof data.body !== "object") {
      throw new TypeError(`Response body can't be ${typeof data.body}`);
    }
    res.statusCode = data.responseCode;
    if (data.headers) {
      for (const key in data.headers) {
        if (data.headers[key]) {
          res.setHeader(key, data.headers[key]);
        }
      }
    }
    if (this.config.LOGGER_VERBOSE) {
      logger.request({
        ip: req.socket.remoteAddress,
        url: req.url,
        method: req.method,
        headers: req.headers,
        body: req.body,
        code: res.statusCode
      }, "New http request");
    } else {
      logger.request(`${req.socket.remoteAddress} - ${req.method} ${req.url} ${res.statusCode} - ${req.headers["user-agent"]}`);
    }
    return res.status(data.responseCode).body(data.body);
  }
  /**
   * Start listening to http incoming requests
   * @param {string} host server host address
   * @param {number} port server port
   * @param {Function} [callback] callback a function to run after starting to listen
   * @example
   * core.listen("0.0.0.0", 80)
   * // or
   * core.listen("0.0.0.0", {
   *      https: 443,
   *      http: 80
   * })
   */
  async listen(host = "127.0.0.1", port = 8e3, callback) {
    const corePreloader = async () => {
      return new Promise((resolve) => {
        const interval = setInterval(() => {
          if (this.routesLoaded && this.configsLoaded) {
            logger.info("All plugins and routes loaded");
            clearInterval(interval);
            resolve();
          } else if (this.passRoutes) {
            clearInterval(interval);
            resolve();
          }
        }, 100);
      });
    };
    await this.#loadConfig();
    await this.#initializePlugins();
    await corePreloader();
    const httpHandler = async (req, res) => {
      try {
        await getRequestBody_default(req);
        this.#handleRequest(req, res);
      } catch (error) {
        logger.error(error, "Unexpected core error");
      }
    };
    const portHandler = (mode) => {
      switch (mode) {
        case "http":
          if (typeof port === "object") {
            return port.http;
          } else {
            return port;
          }
        case "https":
          if (typeof port === "object") {
            return port.https;
          } else {
            return 8443;
          }
        default:
          return 8e3;
      }
    };
    const isHttpsActive = () => Object.keys(this.config.HTTPS || {}).length > 0;
    let httpsServer;
    if (isHttpsActive()) {
      httpsServer = https.createServer(this.config.HTTPS || {}, httpHandler);
    }
    const httpServer = http.createServer(httpHandler);
    if (!callback) {
      callback = (mode) => {
        if (mode === "https") {
          if (isHttpsActive()) {
            logger.core(import_kolor.colors.whiteBright(`Server started on https://${host}:${portHandler("https")}`));
          }
        } else if (mode === "http") {
          logger.core(import_kolor.colors.whiteBright(`Server started on http://${host}:${portHandler("http")}`));
        }
      };
    }
    httpsServer?.listen(portHandler("https"), host, () => callback("https"));
    httpServer.listen(portHandler("http"), host, () => callback("http"));
    httpsServer?.on("error", (e) => {
      logger.error(e, `Starting server failed`);
      process.exit(-1);
    });
    httpServer.on("error", (e) => {
      logger.error(e, `Starting server failed`);
      process.exit(-1);
    });
  }
};

// src/Router/AxonRouter.ts
var duplicateError = (path, method) => {
  throw new RouterException_default({
    msg: "Duplicated route!",
    name: "RouterError -> DUPLICATED_ROUTE",
    meta: {
      type: "DUPLICATED_ROUTE",
      description: `route "${method} ${path}" is duplicated`
    }
  });
};
var AxonRouteHandler = class {
  controller;
  middlewares;
  constructor(controller) {
    this.controller = controller;
    this.middlewares = [];
  }
  middleware(fn) {
    this.middlewares.push(fn);
    return this;
  }
  getController() {
    return this.controller;
  }
  getMiddlewares() {
    return this.middlewares;
  }
};
var AxonRouter = class {
  routes;
  constructor() {
    this.routes = {
      GET: {},
      POST: {},
      PUT: {},
      PATCH: {},
      DELETE: {},
      OPTIONS: {}
    };
  }
  /**
   * Endpoint with method GET
   * 
   * The purpose of the GET method is to simply retrieve data from the server. The GET method is used to request any of the following resources:
   * - A webpage or HTML file.
   * - An image or video.
   * - A JSON document.
   * - A CSS file or JavaScript file.
   * - An XML file.
   * @param path route path
   * @param controller route request controller
   */
  get(path, controller) {
    if (this.routes.GET[path]) {
      duplicateError(path, "GET");
    }
    const handler = new AxonRouteHandler(controller);
    this.routes.GET[path] = handler;
    return handler;
  }
  /**
   * Endpoint with method POST
   * 
   * The POST HTTP request method sends data to the server for processing.
   * 
   * The data sent to the server is typically in the following form:
   * - Input fields from online forms.
   * - XML or JSON data.
   * - Text data from query parameters.
   * @param path route path
   * @param controller route request controller
   */
  post(path, controller) {
    if (this.routes.POST[path]) {
      duplicateError(path, "POST");
    }
    const handler = new AxonRouteHandler(controller);
    this.routes.POST[path] = handler;
    return handler;
  }
  /**
   * Endpoint with method PUT
   * 
   * The PUT HTTP request method sends data to the server for replacing and changing full state.
   * @param path route path
   * @param controller route request controller
   */
  put(path, controller) {
    if (this.routes.PUT[path]) {
      duplicateError(path, "PUT");
    }
    const handler = new AxonRouteHandler(controller);
    this.routes.PUT[path] = handler;
    return handler;
  }
  /**
   * Endpoint with method PATCH
   * 
   * The PATCH HTTP request method sends data to the server for editing part of a data.
   * @param path route path
   * @param controller route request controller
   */
  patch(path, controller) {
    if (this.routes.PATCH[path]) {
      duplicateError(path, "PATCH");
    }
    const handler = new AxonRouteHandler(controller);
    this.routes.PATCH[path] = handler;
    return handler;
  }
  /**
   * Endpoint with method DELETE
   * 
   * The DELETE HTTP request method sends data to the server for deleting a data.
   * @param path route path
   * @param controller route request controller
   */
  delete(path, controller) {
    if (this.routes.DELETE[path]) {
      duplicateError(path, "DELETE");
    }
    const handler = new AxonRouteHandler(controller);
    this.routes.DELETE[path] = handler;
    return handler;
  }
  /**
   * Endpoint with method OPTIONS
   * 
   * The HTTP OPTIONS method returns a listing of which HTTP methods are supported and allowed.
   * @param path route path
   * @param controller route request controller
   */
  options(path, controller) {
    if (this.routes.OPTIONS[path]) {
      duplicateError(path, "OPTIONS");
    }
    const handler = new AxonRouteHandler(controller);
    this.routes.OPTIONS[path] = handler;
    return handler;
  }
  exportRoutes() {
    return this.routes;
  }
};
var AxonRouter_default = AxonRouter;

// src/index.ts
var Router = () => new AxonRouter_default();
var Axon = () => new AxonCore();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Axon,
  AxonCore,
  AxonRouter,
  Router
});
//# sourceMappingURL=index.js.map